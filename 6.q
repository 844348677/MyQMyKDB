/ q中函数式一种算法映射关系，一系列的表达式集合，有可选的输入和输出，
/ 调用函数，表达式计算，参数传入求值，返回一个输入值
/ q中的函数能改变全局变量，q不是纯碎的函数式语言
/ q的函数定义使用一对大括号{}，内部包含可选的参数和一系列表达式
/ 对比强类型语言，输入参数和输出值得类型不需要明确声明，函数名也是可选的
{[x] x*x}
/ 使用方括号来调用函数，方括号里面的值，以此带入到函数参数中，表达式计算，返回值
{[x] x*x}
/ 函数式公民值，看做是long或float值，函数可以赋值给变量，使用变量名调用函数
f:{[x] x*x}
f[3]
/ 函数的定义格式
/ {[p1;...;pn] e1; ...; em}
/ 方括号中的p是参数，e是表达式，有顺序，计算时从左到右，内部单个表达式算术顺序是从右到左
/ 分号是分割符，不是终止符，最后一个表达式后面不要加分号，除非不想有返回值
/ 分号左边的值计算，但是被舍弃，右边的值被计算，被保留
a:2*3;6*7
a
/ 函数中参数个数叫做函数的阶valence，常用的为一阶函数和二阶函数，monadic，dyadic
/ 0阶函数，没有输入参数，函数返回常量，或者产生副作用，调用外部资源
{[] 42} / pure function returns constant 42
{[] a*a} / impure function: references global a
/ 函数支持的最大参数个数为8，多于8的时候可以使用list
/ 输出值是函数编程风格，最后一个表达式为返回值
{[x] x*x}
{[x;y] a:x*x; b:y*y; r:a+b; r}
/ 重载的操作符冒号，一阶函数，强制中介函数的计算，返回操作符右边的表达式结果
{[x] :x*x} / unnecessary use of :
{[x] a:1; :x*x; b:3} / dead code
/ q中的重载规则多种多样，类型，参数的顺序，参数个数，等等
/ 函数调用，正式参数和形式参数平行对应，函数之后用方括号包含正式参数
{[x] x*x}[3]
f:{[x] x*x}
f[4]
{[x;y] x+y}[3;4]
g:{[x;y] x+y}
g[3;4]
/ q是严格的，意思是，调用函数时，传递的参数中的表达式，先计算，再替代形参，可以使用0N!强制输出中间结果
f:{[x] x*x}
f[0N!3+1]
/ 函数的阶valence，也叫作秩rank，传递的函数个数过多，报rank错误
/ {[x] x*x}[3;4]
const42:{[] 42}
const42[]
const42[98.6]
/ 函数没有返回值，不携带有用信息，产生副作用，在最后表达式后面添加分号
fvoid:{[x] `a set x;}
fvoid 42
/ 事实上返回的值通常是双冒号::占位符
-3!fvoid 42
/ 常见的错误想法是把分号当做表达式终止符，而不是分隔符
/ 一元函数的调用，可以省略方括号，函数和正式参数使用空格并列写法，在函数编程中常用
{[x] 2*x} 42
f:{[x] x*x}
f 5
/ 可以使用函数变量的名字调用函数，函数被赋值到全局变量，可以使用变量的名字代替变量本身
f:{x*x}
f[5]
`f[5]
`f 5
.my.name.space.f:{2*x}
`.my.name.space.f[5]
/ 是因为全局变量，使用symbolic-name和函数对创建字典
/ 调用和call-by-name不要混淆
/ 隐式参数，常用的参数x和y和z，如果函数使用着三个参数，可以省略声明，省略方括号
{[x] x*x}
{x*x}
{[x;y] x+y}
{x+y}
/ x为第一个，y为第二个，z为第三个
g:{x+z}  / likely meant x+y; requires 3 args in call
g[1;2]   / still waiting for 3rd arg C i.e., a projection
g[1;2;3] / 2nd arg is required but ignored
/ q中函数没有被赋值给变量，就是匿名函数，也叫作lambda表达式，lambda的叫法是早起的排版错误lambda calculus
/ 匿名函数可以当做内部宏来使用，在集合里面使用内部函数，根据位置index，选择对应的函数
powers:({1}; {x}; {x*x}; {x*x*x})
selected:2
powers[selected]
/ 恒等函数，输入值等于输出值，::调用，恒等函数的调用使用方括号，不能省略
::[42]
::[`a`b`c]
/ :: 42 / error
(::) 42
/ q中数据 atom，list，dictionary，函数也是data，可以作为list中的元素
(1; 98.6; {x*x})
f:{x*x}
(f; neg)
(f; neg)[0]
(f; neg)[1; 5]
/ 函数可以作为另一个函数的输入或者输出
apply:{x y}
sq:{x*x}
apply[sq; 5]
/ 一个函数操作另一个函数，叫做高阶函数，高阶函数在函数式编程中很重要的概念，导数和不定积分
/ 函数调用的时候，正式参数和形式参数进行复制，当输入数据很大的时候，不能复制，使用call-by-name，传递变量名，而不是变量的值
/ get获取全局变量的值，通过变量的名字
a:42
get `a
/ set通过变量的名字，对变量进行赋值
`a set 43
a
/ 在函数内部使用冒号赋值的变量，叫做局部变量
f:{a:42; a+x}
/ 局部变量的最大个数是24
/ 局部变量在函数调用期间存在，没有静态局部变量的概念
/ 局部变量对外部不可见
/ 局部变量不用使用call-by-name的方式作为q函数中的参数
/ 局部变量对于内部函数也是不可见的，q中没有作用域有关的词，没有public，private
/ f:{[p1] a:42; helper:{[p2] a*p2}; helper p1}
/ f 5
/ 内部函数调用局部变量的时候，需要把局部变量当做参数传递进去
f:{[p1] a:42; helper:{[a; p2] a*p2}[a;]; helper p1}
f 5
/ 在外部定义赋值的变量叫做全局变量
b:7
f:{b*x}
f[6]
/ 全局变量个数最大值是32个
/ 可以在函数内部对全局变量赋值，使用双冒号::，表示不使用局部变量，而是使用全局变量
b:6
f:{b::7; x*b}
f[6]
b
/ ::的使用类似于+:，-:，而不是只使用赋值操作符，不是真正的操作全局变量的操作符
/ 如果已经有了局部变量和全局变量同名，再使用双冒号的时候，是对局部变量赋值
b:6
f:{b:42; b::x; b}
f[98]
b
/ 不要使用双冒号操作全局变量，如果要对全局变量进行操作，使用set和call-by-name的方式
a:42
f:{a:98.6; `a set x}
f 43
a
/ projection表示在函数调用的时候传递一部分参数，结果返回需要传递另一部分参数的函数
add:{x+y}
add[42;]
add[42;][3]
/ 函数是一级的，可以对投影之后的函数再次赋值到变量
g:add[42;]
g[3]
/ 在函数式编程中，叫做柯里化，对两个参数的函数，传递一个参数，返回需要另一个参数的函数
add3:{x+y+z}
add3[2][3][4]
/ 书写格式，推荐不要省略尾部的分号，可以得出函数的参数个数
/ mystery:f[2] / surprise! f is actually f:{x+y+z}
/ projection中的方括号是不可省略的，如果得到的是一元参数函数，调用的时候可以省略方括号
{x+y}[42;][3]
{x+y}[42;] 3
/ projection被定义为第一次遇见该函数，如果之后原函数变化，projection的函数不变
f:{x-y}
g:f[42;]
g
g[6]
f:{x+y}
g 
g[6]
/ 操作符映射，q中的内置函数，当时用前缀操作符时，左边参数和操作符使用括号合并，就是projection
(7*)
(7*) 6
/ 操作符可以使用前缀写法，使用方括号调用函数
-[;42] 98
/ 如果不会产生歧义，并列写法的空格可以省略
(7*)6
-[;42]98
/ 多阶函数，同样可以使用projection
{x+y+z}[1;;3]
{x+y+z}[1;;3] 2
/ 三阶函数，传第一个参数，返回二阶函数
{x+y+z}[1;;]
{x+y+z}[1;;][2;3]
{x+y+z}[1;;][;3]
{x+y+z}[1;;][;3] 2
{x+y+z}[;;3][1;]
{x+y+z}[;;3][1;] 2
/ q中的数据结构和函数都是map
/ 可以发现list的index，dictionary的lookup，一元函数的调用，都是一致的
L:0 1 4 9 16 25 36
f:{x*x}
L[2]
L 2
f[2]
f 2
/ list是map结构，可以通过索引来检索对应位置，dictionary是map，可用通过键值对来查找，fuction是map结构，输入输出的映射
L:10 20 30 40 50
L[2 5]
I:2 5
L I
d:`a`b`c!10 20 30
ks:`a`c
d ks
f[2 5]
f I
/ 深度索引和多阶函数也是相似的
a:(1 2 3; 100 200)
a
a[1;0]
/ 字典的值列表式复杂结构，也是多阶的映射关系
d:`a`b!(1 2 3; 100 200)
d[`a;1]
/ 同时缺失索引和projection也是相似的
m:(10 20 30; 100 200 300)
m
m[1;2]
L:m[;2]
L
L[1]
/ 索引越界，产生null值，表示缺失数据，null值得类型
10 20 30 40[100]
`a`b`c[-1]
(1.1; 1; `1)[3]
d:`a`b`c!10 20 30
d[`x]
neg 10
neg 10 20 30
neg (10 20 30; 40 50)
neg `a`b`c!10 20 30
neg `a`b`c!(10 20; 30 40 50; 60)
/ 一元原子函数，输出的结果的形状和输入一致
/ 函数作用在list，相当于以此作用在list上每个元素上，传统编程语言叫foreach，函数式语言叫map
10 20 30?10
10 20 30?10 20 30 40 50
(enlist 10)?10
10 20?10
10 20 30 40 50?10
/ 算术，比较，关系运算符，4种调用情况，atom with atom，atom with list，list with atom，list with list
/ 如果作用在两个list上，list的长度必须相等
1+10
1+10 20 30
1 2 3+10
1 2 3+10 20 30
/ 创建一元和二元atomic function
f:{(x*x)+(2*x)-1}
f 0
f til 10
pyth:{sqrt (x*x)+y*y}
pyth[1; 1]
pyth[1; 1 2 3]
pyth[1 2 3; 1 2 3]
/ adverb是高阶函数，将函数调用作用在list上，函数不都是atomic，但是仍然希望作用在数据结构是没有循环代码
neg (1 2 3; 4 5)
/ aggregate聚合函数，接受list，不是作用在atom上，聚合函数作用在嵌套循环的时候，只作用在顶层
count 10 20 30
count (10 20 30; 40 50)
/ 如果想要作用在嵌套循环中的每一个内层，需要使用adverb中的each，修饰一元函数，作用在list的内部每个元素，而不是整个list
count each (10 20 30; 40 50)
/ 我上面好像搞混了一个概念，高阶函数，和多参数函数，姑且这样吧，之后注意
/ each的本质是高阶函数，使用前缀表达式更清晰，each接收一个函数和一个list，将函数依次错用在list的内部元素中
each[count] (10 20 30; 40 50)
/ each类似foreach和map的用法
/ 多层嵌套，使用多个each
(count each) each ((1 2 3; 3 4); (100 200; 300 400 500))
each[each[count]] ((1 2 3; 3 4); (100 200; 300 400 500))
count (1 2 3; 10 20 30)
count each (1 2 3; 10 20 30)
(count each) each (1 2 3; 10 20 30)
/ each可以修饰所有的一元函数，尽管有些是多余的
reverse "live"
reverse ("life"; "the"; "universe"; "and"; "everything")
reverse each ("life"; "the"; "universe"; "and"; "everything")
neg each (1 2 3; 4 5)
/ each可以将一个长度为n的向量，转成n*1的矩阵，可以使用enlist each，但是flip enlist执行效率更快
enlist each 1001 1002 1004 1003
flip enlist 1001 1002 1004 1003
1 2 3+10 20 30
"abc","de"
/ 配对合并
("abc"; "uv"),'("de"; "xyz")
/ 副词each-both使用操作符'，接受一个二元函数，接受两个长度相等的list，两个list对应位置进行配对操作，zip
("abc"; "uv"),'("de"; "xyz")
/ each-both和verb之间没有空格，当'作用在两个原子上，不起任何作用
3,'4
/ 如果两个list长度不同，报错
/ ("abc"; "uv"),'("de"; "xyz"; "uhoh")
/ each-both的两个参数可以有原子，atom match a list，原子会扩展成list，进行zip操作
1,'10 20 30
1 2 3,'10
2#'("abcde"; "fgh"; "ijklm")
/ 可以使用前缀操作符，函数式编程格式
,'[("abc"; "uv"); ("de"; "xyz")]
/ ,'在操作两个simple list没有问题，但是作用在general list会产生期望外的情况，例如缺失单例的属性
L1:(enlist `a; `b)
L2:1 2
L1,'L2
/ 可以信赖的方式创建列表对
flip (L1; L2)
/ ,'对table使用，使得两个table合并
t1:([] c1:1 2 3)
t2:([] c2:`a`b`c)
t1,'t2
/ each-left使用\:意思是将右边参数，依次作用在左边list，进行函数操作
1 2 3+10
("abc"; "de"; enlist "f") ,\: ">"
/ each-right使用/:意思是将左边参数，依次作用在右边list，进行函数操作
10+1 2 3
"</" ,/: ("abc"; "de"; enlist "f")
"</",/:("abc"; "de"; enlist "f"),\:">"
/ each-right和each-left一起用/:\:笛卡尔积，左边的每个对应右边的每个，重构形状使用raze，cross
1 2 3,/:\:10 20
raze 1 2 3,/:\:10 20
1 2 3 cross 10 20
/ each-rigth和each-left有顺序关系，/:\:，\:/:
raze 1 2 3,\:/:10 20
/ 累积使用/，在q中提供迭代循环，常用作二元函数，对list进行累积结果
0 +/ 1 2 3 4 5 6 7 8 9 10
/ 使用0N!强制打印输出
addi:{0N!(x;y); x+y}
0 addi/ 1 2 3 4 5
/ 高阶函数/，接受一个二元函数，返回二元函数，左边初始值，以此累加右边list
/ reduce
/ 通常左边的初始值，不是必须的，list以此累积，操作符和/使用括号包围
(+/) 1 2 3 4 5 6 7 8 9 10
/ 使用前缀写法
+/[0; 1 2 3 4 5 6 7 8 9 10]
+/[1 2 3 4 5 6 7 8 9 10]
(*/) 1 2 3 4 5 6 7 8 9 10 / product
(|/) 7 8 4 3 10 2 1 9 5 6 / maximum
(&/) 7 8 4 3 10 2 1 9 5 6 / minimum
(|/) `long$()
(|/) `float$()
(&/) `long$()
(+/) `long$()
(*/) `long$()
(,/) ()
/ 操作符,/，有效的消除顶层嵌套，如果只有一层嵌套，编程一个普通列表，raze是一样的操作
(,/)((1 2 3; 4 5); (100 200; 300 400 500))
raze ((1 2 3; 4 5); (100 200; 300 400 500))
f:{2*x+y}
100 f/ 1 2 3 4 5 6 7 8 9 10
(f/) 1 2 3 4 5 6 7 8 9 10
/ 另一种递归的形式，等价于循环代码，该重载的/操作符，左边元素是自然数，指明迭代次数，右边参数时初始值
/ 可以使用中缀和前缀的额写法
fib:{x,sum -2#x}
10 fib/ 1 1
fib/[10; 1 1]
/ 另一个版本的/运行到递归知道收敛，或者直到循环结束，牛顿迭代
f:{-2+x*x}
secant:{[f;x;e] (f[x+e]-f x-e)%2*e}
{x-f[x]%secant[f; x; 1e-6]}/[1.5]
/ q如何决定收敛，每一步和上一步作比较，10^-14为阈值
/ 有可能陷入无限循环，x^3 C 2x + 2 ,选着初始值为0
newtcycle:{[xn] xn-((xn*xn*xn)+(-2*xn)+2)%-2+3*xn*xn}
newtcycle/[0.0]
/ 最后一种形式类似于while循环，第一个参数为循环条件，为true就循环
fib:{x,sum -2#x}
fib/[{1000>last x}; 1 1]
/ 反斜杠\和作用和/是一样的，但是会返回累加中的所有中间产物，scan函数生成的输出值和输入值得长度相同
0+\1 2 3 4 5 6 7 8 9 10
(*\)1 2 3 4 5 6 7 8 9 10
(|\)7 8 4 3 10 2 1 9 5 6
(&\)7 8 4 3 10 2 1 9 5 6
100 f\1 2 3 4 5 6 7 8 9 10
(f\)1 2 3 4 5 6 7 8 9 10
/ newtsqrt[1.0]
/ each-previos声明的一种方式，二元操作符，每一个元素执行的操作根据前项操作一样
/ 因为第一项没有前项，所以左边参数时初始操作
/ 例如计算价格的变化量，当前项减去前一项
100 -': 100 99 101 102 101
/ 如果为一元函数，没有左边初始值，则第一项直接返回
(-':)100 99 101 102 101
deltas 100 99 101 102 101
(%':)100 99 101 102 101
ratios 100 99 101 102 101
sums deltas 100 99 101 102 101
deltas sums 100 99 101 102 101
/ 价格变化量
deltas sums 100 99 101 102 101
/ 等同于设置初始值
deltas0:{first[x] -': x}
deltas0 100 99 101 102 101
/ 用在和match和not match，一同使用
(~':) 1 1 1 2 2 3 4 5 5 5 6 6
not (~':) 1 1 1 2 2 3 4 5 5 5 6 6
differ 1 1 1 2 2 3 4 5 5 5 6 6
/ 使用where查找not math中的1b的index位置
L:1 1 1 2 2 3 4 5 5 5 6 6
where differ L
(where differ L) cut L
/ 下面的一段操作是真的有点懵了
runs:(where differ L) cut L / store runs
ct:count each runs / store count of each run
runs where ct=max ct / find the runs of maximum length
runs where ct=max ct:count each runs:(where differ L) cut L
/ 查找递减和递增的子列表
L:9 8 7 11 10 12 13
(where -0W>':L) cut L
(where 0W<':L) cut L
/ 整数无穷存在的理由？
/ list使用索引，dictionary使用key查找，函数调用，都是用方括号和并列写法
L:(1 2;3 4 5; enlist 6)
L[0]
L 1
L[0 2]
L[1][2]
L[1; 2]
d:`a`b`c!(1 2; 3 4 5; enlist 6)
d[`a]
d `a
d[`a`c]
d[`a][1]
d[`a; 1]
f:{x*x}
f[0]
f 1
f[0 2]
g:{x+y}
g[1][2]
g[1;2]
/ 语法糖，调用函数也是高阶函数，将函数和值一起传入进去
/ 高阶函数@ 在q中是基础调用，接受一元映射关系为参数，可以使用中缀和前缀形式
10 20 30 40@1
L:10 20 30 40
L@1
@[L; 1]
count@L
@[count; L]
{x*x}@L
d:`a`b`c!10 20 30
d@`a
@[d;`b]
/ 当时用无参数函数时，使用占位符::
f:{6*7}
f[]
@[f; ::]
f@(::)
f@43
/ 对于list，dictionary和一元函数，@调用时候，输出值形状和输入一致
/ 聚合操作，解开嵌套循环的第一层
/ @同样可以作用在table和keyed table上
t:([]c1:1 2 3; c2:`a`b`c)
t@1
d:`a`b`c!10 20 30
d@`b
kt:([k:`a`b`c] v:1.1 2.2 3.3)
kt@`c
/ list的深度索引，dictionary的嵌套值，和多参数函数，是多重映射干洗，高阶函数.来调用，
/ 点.的右边参数必须是list
L:(10 20 30; 40 50)
L[1][0]
L[1; 0]
L . 1 0
d:`a`b`c!(10 20 30; 40 50; enlist 60)
d[`b][0]
d[`b; 0]
d . (`b; 0)
g:{x+y}
g[1; 2]
g . 1 2
g:{x+y}
f:g
f . 1 2
h:{x+y+z}
f:h
f . 1 2 3
/ .可以调用一元函数，但是参数必须是单例list，使用enlist构造
f:{x*x}
f@5
f . enlist 5
f . enlist 1 2 3
/ .可以用在任意参数个数的函数上，而@不行
/ 缺失索引，使用双引号占位符表示::
m:(1 2 3;4 5 6)
m[0;]
m . (0; ::)
m . (::; 1)
f:{6*7}
f . enlist (::)
f . enlist 42
/ q中的所有数据结构都是list和dictionary，@调用非嵌套，.调用嵌套
L:10 20 30
L . enlist 1
m:(10 20 30; 100 200 300)
m . 0 1
ds:(`a`b`c!10 20 30; `x`y!100 200)
ds . (0; `b)
mix:(10 20 30; `a`b`c!(1; 2; (300 400)))
mix . (1; `c; 1)
dc:`c1`c2!(1 2 3; `a`b`c)
dc . (`c2; 1)
t:([]c1:1 2 3;c2:`a`b`c)
t . (1; `c2)
kt:([k:`a`b`c] v:1.1 2.2 3.3)
kt . `b`v
t:([] c1:`a`b`c; c2:(1 2; 100 200 400; enlist 1000))
t . (1; `c2)
/ t . (1; `c2; 1)
t . (1; `c2; 1)
/ 前缀格式
L:10 20 30 40 50
@[L; 1]
@[L; 0 2]
m:(10 20 30; 100 200 300)
.[m; 0 2]
L:10 20 30 40 50
@[L; 1]
@[L; 0 2]
/ 不仅仅是在子域上检索，而且可以传递函数，作用在子域上
@[L; 1; neg]
@[L; 0 2; neg]
/ 整个数据结构返回，而不是子域返回
neg L@0 1
/ 在列表中，指定元素，进行指定函数操作，格式为，@[L;I;f]
d:`a`b`c!10 20 30
ks:`a`c
@[d; ks; neg]
/ 嵌套结构，@作用在子域的顶层数据结构上
m:(10 20 30; 100 200 300; 1000 2000 3000)
@[m; 0 2; neg]
/ 所有例子都是生成新的copy数据结构，可以直接作用在原始数据上，修改值，使用pass-by-name
L:10 20 30 40
@[L; 0; neg]
L
@[`L; 0 ; neg]
L
/ @中传递二元函数，最后的参数需要传递值，值的形状需要与选择的子域匹配，值为atom，自动扩展为list
L:10 20 30 40
@[L; 0 1; +; 100 200]
@[L; 0 1; +; 100]
d:`a`b`c!10 20 30
@[d; `a`b; +; 100 200]
@[d; `a`b; +; 100]
/ 调用的一般格式为 @[L; I; g; v]
L:10 20 30 40
@[L; 0 1; +; 100 200]
100 200+L@0 1
/ 可以用在其他的数据结构上
m:(10 20 30; 100 200 300; 1000 2000 3000)
@[m; 0 2; +; 1 2]
/ @内传递的函数时赋值操作符:，对选择的子域进行赋值
L:10 20 30 40
@[L; 0 2; :; 42 43] 
L:10 20 30 40
@[`L; 0 2; :; 42 43]
L
/ @是作用在顶层结构，深度索引使用.，使用.操作嵌套数据结构
m:(10 20 30; 100 200 300)
.[m; 0 1]
d:`a`b`c!(10 20 30; 40 50; enlist 60)
.[d; (`a; 1)]
/ .能达到数据的单个点
.[d; (`a; 1)]
.[d; (`a; 1); neg]
/ 数据的复制，和对原始数据的修改
.[m; 0 1; neg]
.[`m; 0 1; neg]
.[d; (`a; 1); neg]
.[`d; (`a; 1); neg]
/ 索引省略，使用占位符双引号::，表示作用在该level的所有索引对应的值上
.[m; (0; ::); neg]
.[d; (`a; ::); neg]
.[d; (::; 0); neg]
/ 格式为.[L; I; f]，L是数据结构，I是子域的深度索引，f是作用在值上的一元函数
/ .作用在二元函数上，.[L; I; g; v]
m:(10 20 30; 100 200 300)
.[m; 0 1; +; 1]
.[m; (::; 1); +; 1 2]
m
.[`m; (::; 1); +; 1]
m
.[`m; (::; 1); :; 42]
m
d:`a`b`c!(100 200 300; 400 500; enlist 600)
.[d; (`a; 1); +; 1]
.[d; (`a; ::); +; 1]
.[d; (::; 0); +; 1]
d
.[`d; (::; 0); :; 42]
d