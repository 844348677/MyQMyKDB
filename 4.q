/ 操作符可以叫做verb，类似+，三种说法，operator，function，verb
/ 操作符是内置函数，可以使用中缀写法
/ 个人函数需要字母名字，内置可以使用符号，个人定义函数只能使用前缀，不能使用中缀
/ 函数调用使用方括号，分号分割多个参数
2+3
+[2;3]
=[2;3]
(2+)[3]
(2+)3
/ 作用于原子的函数，在作用在list上，会自动扩展到每个元素上，合并两个list必须相同的长度
neg 1 2 3
1 2 3+10 20 30
/ 1 2 3+10 20 30 40
/ 同样适用于嵌套列表，生成的格式相对应
neg (1 2 3; 4 5)
(1 2 3; 4 5)+(100 200 300; 400 500)
/ 当参数时原子时，能隐式的扩展参数匹配list
100+1 2 3
1 2 3+100
100+(1 2 3; 4 5)
(1 2 3; 4 5)+100
/ 操作符没有优先级，从右到左的计算顺序，可以减少括号的噪音影响
2*3+4
(2*3)+4
4+2*3
(2+3)*3+4
/ 如果操作符左边的参数，同样也是表达式，需要使用括号
/ 非原子二元匹配操作符~，接受两个q实体参数，返回布尔值，如果一致为1b，否则0b，
/ 两个参数必须同样的形状，同样的类型，同样的值，可以不是同一个存储地址，克隆clone也是一致的
/ q中的identity，不需要同一个对象，同一个指针，同一块内存地址，深度复制也是可以的
/ 两个参数不需要类型一致，任何q实体都可以使用match~
42~40+2
42~42h
42f~42.0
42~`42
`42~"42"
4 2~2 4
42~(4 2;(1 0))
(4 2)~(4;2*1)
(())~enlist ()
(1; 2 3 4)~(1; (2; 3; 4))
(1 2;3 4)~(1;2 3 4)
42~(42)
/ 相等比较，类型不同，但是必须兼容
/ 判断相等和对比操作符，atomic function返回boolean值，比较操作符不需要类型匹配，但是需要兼容
/ 相等运算符=与match不同，相等是原子属性，数值，时间，字符类型可以判断相等，symbol只能和symbol
/ 相等判断两个参数的值是否相等，不考虑类型
42=42i
42=42.0
42=0x42
42="*"
/ 时间类型值判断的相等时日历和时钟是否相等，不是底层隐含的数值
2000.01.01=2000.01.01D00:00:00.000000000
2015.01.01<2015.02m
12:00:00=12:00:00.000
/ symbol不能和字符做比较
/ `a="a"
/ 不等号使用 <>
42<>0x42
/ 不等可以使用not
not 42=98.6
r:1%3
r
2=r+r+r+r+r+r
/ not接受一元原子参数，数值，时间，字符类型，不接受symbol，翻转true和false
not 0b
not 1b
not 0b
not 1b
not 42
not 0
not 0xff
not 98.6
/ not之后接受0，才返回true
not "*"
not " "
not "\000"
/ 时间类型值，底层为0的时候返回1，否则返回0
not 2000.01.01
not 2014.01.01
not 2000.01.01T00:00:00.000000000
not 2000.01m
not 00:00:00
not 12:00:00.000000000
/ 比较运算符，> <= > >=，作用能兼容的atom类型，数值和字符，symbol和symbol
4<42
4h>0x2a
-1.4142<99i
/ 时间类型，比较日期和时刻点前后
-1.4142<99i
2015.01.01<2015.02m
12:00:01>12:00:00.000
/ 字符char，比较ASCII的顺序
"A"<"Z"
"a"<"Z"
"A"<"O"
"?"<"?"
/ 打印所有ASCII码值
16 16#"c"$til 256
/ symbol比较字典顺序
`a<`b
`abc<`aba
/ 作用在数据结构上，自动匹配对应位置
2 1 3=1 2 3
10 20 30<=30 20 10
2=1 2 3
"zaphod"="Arthur"
/ `a`b`a`d=`ad`a`b
`a`b`a`d=`a`d`a`b
/ 基础算术操作符
/ 加减乘除 + - * %，任何数值型类型，时间类型
2+3
a:6
b:7
b-a
a*b
4%2
6*3+4
/ 类型提升，二进制数据提升为int，结果为最窄的类型，但是比两个参数的类型要宽
1b+1b
42*1b
5i*0x2a
/ 上溢出和下溢出，不被限制在整数的运算操作符中
9223372036854775806+4 
2*5223372036854775800
-9223372036854775806-4 
/ 表达式中有浮点值，结果也为浮点值
6+7.0
1.0+1b
6.0*7.0e
/ -负号运算符使用在字面量，不能使用在变量上，变量使用neg
42 
-42
a:42
/ -a
neg a
/ 自动提升为宽类型
1.0+10 20 30
10 20 30%1 2 3
100 200 300+1b
1+(100 200;1000 2000)
/ 二元原子操作符，计算两个变量的最大是最小值&|，兼容性与算术运算符相似，不支持symbol和guid
/ |返回两者最大值，&返回两者最小值
42|43
98.6&101.9
0b|1b
1b&0b
42|0x2b
"a"|"z"
/ "a"|"z"
2|0 1 2 3 4
11010101b&01100101b
"zaphod"|"arthur"
/ 可以使用or和and，代替&|
1b or 0b
1b and 0b
42 or 43
/ Amend，重载冒号:，类似其他语言+=，运算再复制
a:42
/ q中使用+:
x:42
x+:1
x
a:43
a-:1
a
a&:21
a
/ q中，即使x没有进行赋值，也是可以使用amend
/y
/y+:42
/y
/ 对list使用amend，修改对应index位置的值
L:100 200 300 400
L[1]+:99
L[1 3]-:1
L
L1:(1 2 3; 10 20 30)
L1[;2]+:100
L1
/ 很有用的操作符 ,: 对list进行添加操作
L:1 2 3
L,:4
L
L,:100 200
L
/ ,:需要进行严格的类型匹配
L:1.1 2 2 3.3
L[1]+:100
/ L,:100
/ 指数操作，sqrt，exp，log，xexp，xlog
/ sqrt一元原子操作符，参数是数值型，返回该值平方根，如果没有跟，返回null值
sqrt 2
sqrt 42.4
sqrt 1b
sqrt -2
/ exp一元原子，返回e的参数次方
exp 1
exp 4.2
exp -12i
/ exp不要和科学计数法的e混淆
/ log求自然数为底，传入参数的对数
log 1
log 42.0
log .0001
log -1
/ xexp，以左边参数为底，右边参数为指数，返回左参数的右参数次方，没有返回null值
2 xexp 5
-2 xexp .5
/ q的命名规则，带x表示多元
/ xlog，以左边参数为底，求右边参数的对数，未定义值返回null
2 xlog 32
2 xlog -1
/ div接收两个参数，右值不为负，返回飞负值，左值除以右值，返回小于结果的最大的整数
/ div实际使用的时候有问题，右参数可以为负值
7 div 2
7 div 2.5
-7 div 2
-7 div 2.5
7 div -2
3 4 5 div 2
7 div 2 3 4
3 4 5 div 2 3 4
/ mod求模，
7 mod 2
7 mod 2.5
-7 mod 2
-7 mod 2.5
7 mod -2
3 4 5 mod 2
7 mod 2 3 4
3 4 5 mod 2 3 4
/ sign根据数值符号，返回1i，-1i，0
signum 42
signum -42.0
signum 1b
signum 0
signum 1999.12.31
signum 12:00:00.000000000
/ reciprocal求到倒数，1.0除以参数，无穷值得倒数为0，0的倒数为无穷，根据符号判断正负无穷
reciprocal 0.02380952
reciprocal 0.0
reciprocal -0.0
/ floor接受数值，返回小于该值的最大整数，类型为long
floor 4.2
floor 4
floor -4.2
/ ceiling大于该值的最小整数，long
ceiling 4.2
ceiling 4
ceiling -4.2
/ floor和ceiling不接收short类型的值，否则报错
/ abs求绝对值，布尔值会提升为int类型
abs 42
abs -42
abs 1b
/ 将时间类型值强转为整数值
`int$1999.12.31
`int$2013.01m
`int$12:00:00.123
`long$12:00:00.123456789
/ q没有时区的概念
/ 时间类型的比较，不是依靠强转的整数值，而是对应的时间点的比较，数值上类似于单位不同
`long$12:00:00.123456789
`int$2000.01.02
`long$2000.01.02D02:00:00.000000000
/ 若对比数值，可以强转为双方较细的单位类型，进行数值比较
`timestamp$2001.01.02
2000.01.01<2000.01.01D12:00:00.000000000
/ 可以对时间类型和数值型类型进行比较，
2000.01.01=0
12:00:00=12*60*60
12:00:00=12*60*60
/ 对时间类型，加上整数值
2014.12.31+1
2015.01.01+til 31 / all days in January
12:00:00+1
/ 一个时间值，加上零一个是时间值
12:00:00+01:00:00
/ 一个很重要用法，date类型值，加上timespan类型值，生成timestamp类型值
2015.01.01+12:00:00.000000000
/ 两个时间类型值相减，得到底层数值相减的值
2001.01.01-2000.01.01
2015.06m-2015.01m
/ 两个time类型值相减，得到的还是相同的time类型
2015.01.01D00:00:00.000000000-2014.01.01D00:00:00.000000000
12:00:00-11:00:00
12:00-11:00
/ 0Wh 0111111111111111b
/ -0Wh 1000000000000001b
/ 0Wi 01111111111111111111111111111111b
/ -0Wi 10000000000000000000000000000001b
/ 0W 0111111111111111111111111111111111111111111111111111111111111111b
/ -0W 1000000000000000000000000000000000000000000000000000000000000001b
/ 无穷之和自己相等，null指和自己相等，=~，不同类型的null不能比较
(0%0)=0%0
/ not操作符对无穷和null值，都会返回0
not 0W
not -0w
not 0N
/ neg正无穷返回负无穷，负无穷返回正无穷，null值返回null值
neg 0W
neg -0w
neg 0N
/ null < negative infinity < normal value < positive infinity
/ 不同类型的null值虽然相等，但是不具有比较的意义，其他关系操作符都返回0b
/ 不同类型的正无穷大小顺序，short < int < long < real < float
/ 不同类型的负无穷大小顺序，short < int < long < real < float
42<0W
-0w<42.0
-0w<1901.01.01
-0w<0w
0W<0w
-0w<0W
-10000000<0N
0N<42i
0n<-0w
`a<`
42|0W
-42&0N
0w|0n
-0w&0n
0n|0N
0Wi&0W
/ 0Wi和0W求最小，int的最大值提升为long，做大正32bit的整数
/ q是精确的，往往表达式在输入的时候就进行计算，尤其在赋值的时候，变量右边表达式先计算
/ 别名alias是表达式的变量，不是表达式的计算结果，而是表达式本身，alias提供表达式延迟计算
/ 别名计算时懒加载，仅在使用的时候计算，变量引用的时候强制计算
/ 第一次引用的时候计算，或者在最后一次调用之前，表达式相关联的值发生变化，进行计算，结果值会保存，下次调用直接返回，memoized
/ 如果表达式中的变量值没有发生变化，memorized的值直接返回
/ 使用双冒号::，来对左边的别名赋值右边参数的表达式，
a:42
b::a
c:a
a:43
b
c
/ 对于c赋值是字面量，对于b赋值是表达式a
w::(x*x)+y*y
x:3
y:4
w
y:5
w
/ 使用命令0N!强制在控制台输出结果
w::(0N!x*x)+y*y
x:3
y:4
w
w
y:6
w
/ w在第一次调用的时候计算，在值改变之后调用再次计算
/ 
fu:{(x*x)+y*y}
fu[3;4]
/ 函数调用的时候，传递参数，函数计算，函数的结果值，没有memoize
/ alias变量依赖于表达式中的实体，例如w依赖于x和y，.z.b命令能显示以来dictionary，相同的命令\b
w::(x*x)+y*y
w
/ .z.b
/ 所有的key都是表达式设计的实体
/ 多重依赖，依赖的依赖
u::w*w
x:3
y:4
u
/ 递归定义会产生层次依赖关系，变量不仅依赖于自己的表达式中的变量，还依赖于变量自己的表达式，小心不可维护
/ 依赖链不可造成loop回环，
/ alias通常用作数据库的视图view，保存查询表达式
t:([]c1:`a`b`c`a;c2:20 15 10 20;c3:99.5 99.45 99.42 99.4)
v::select sym:c1,px:c3 from t where c1=`a
v
update c3:42.0 from `t where c1=`a
v
.z.b