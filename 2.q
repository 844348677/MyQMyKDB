/ 所有数据的最终构成都是有原子组成，不可分割的值，有关时间序列的date和time，也是基本属性
/ q3.0之后默认的基础整数型是long，后缀标识符是j，8byte大小，j可以省略
42
42j
/ short的后缀标识符是h，int的后缀标识符是i，
-123h
1234567890i
/ 在使用算数运算符计算的时候，类型自动提升，窄类型自动提升为宽类型
/ 单精度和双精度浮点数都支持，推荐使用双精度
/ IEEE标准8byte浮点数，double，至少15位小数，f
3.14159265
1f
1.0
/ float可以使用科学计数法，e表示10的次方
1.234e07
1.234e-7
/ real是单精度浮点数，4byte浮点值，后缀标识符使用e，至少保存6位小数
/ q控制台默认显示7位有效数字，做多显示16位有效数字，
/ 使用\P 16来修改，当\P 0的时候，显示17位有效数字，通过底层的二进制，尽管数据不真实
f:1.23456789e-10
r:1.2345678e-10e
f
r
f12:1.23456789012
f16:1.234567890123456
/ 二进制数据，一个bit或byte值
/ 布尔值用一个byte保存一个bit值，尾部必须加上标识符b
/ 去中没有关键字，true或者false
0b
1b
/ 二进制在计算时，隐式转换为无符号整数值
42+1b
3.1415+0b
/ byte用一个byte存无符号的16bit的值，前缀标识符0x,后面两位16进制数值，字母大小写都行，推荐小写
0x2a
0x2A
/ 和boolean一样，byte制动转成int
1+0x29
/ GUID 16byte的二进制数据，通过时间和空间，创建出唯一值
/ 使用问号?加上0Ng来创建guid的列表，左边参数定义个数
1?0Ng
2?0Ng
-1?0Ng
-2?0Ng
/ 正负值的不同在于，正值使用的是同一个生成器种子，负值使用随机生成器种子，正值为了可再生
/ 可以解析16进制数据，导入guid
"G"$"61f35174-90bc-a48a-d88f-e15e4a377ec8"
0x0 sv 16?0xff
/ guid可用的操作符~, =, <, > and null
/ 文本数据类型
/ 两种基础的原子文本类型，类似CHAR和VARCHAR
/ 一个char，独立的ASCII码，8bit大小Unicode字符，CHAR，使用双引号引用创建
"q"
/ 某些键盘值，无法输入，使用转义字符，反斜杠\
"\""
"\\"
"\n"
"\r"
"\t"
/ 通过ASCII码底层的三位数字，转义字符
"\142"
/ symbol保存text文本，原子属性，`叫做back tick
`q
`zaphod
/ 在q中symbol被用作其他名字，所有的名字都是symbol，但不是所有的symbol都是名字
/ 弄清char的list不是symbol，string是由char组成的list，symbol不可分
`a~"a"
/ 使用强转操作符，将string转成symbol
`$"A symbol with blanks and `"
/ 时间类型
/ 时间使用日历和时钟组成的测量单位，q处理时间序列很高效
/ date类型大小为4byte，有符号的整数，格式为yyyy.mm.dd，2000.01.01为0，之前为负，之后为正
2015.01.01
2000.01.01=0
2000.01.01=0
1999.12.31=-1
/ 01前面的0不可省略，缺失会造成错误
/ date强转成整数
1999.12.31=-1
/ time类型，如果毫秒满足需求，使用time类型，32bit的有符号整数值，格式为hh:mm:ss.uuu
12:34:56.789
12:00:00.000=12*60*60*1000
/ 强转成int
12:00:00.000=12*60*60*1000
/ 如果毫秒值不够用，使用timespan，纳秒单位，格式为0Dhh:mm:ss.nnnnnnnnn，开头0D可选
12:34:56.123456789
12:34:56.123456 / microseconds become nanos
/ 强转成long值
`long$12:34:56.123456789
/ 两种date-time类型，第一种不推荐
/ datetime，是date和time两种类型组合成的一种类型，之间使用T分隔符，2000.01.01为0
2000.01.01T12:00:00.000
2000.01.02T12:00:00.000=1.5
`float$2000.01.02T12:00:00.000
/ 从date-time类型中抽取date和time
`float$2000.01.02T12:00:00.000
`time$2000.01.02T12:00:00.000
/ 不要用datetime当做key，或者join条件，会出错
/ 推荐的类型为timestamp，是date和timespan的组合，分隔符使用D，long值，纳秒
2014.11.22D17:43:40.123456789
`long$2014.11.22D17:43:40.123456789
/ 抽取timestamp中的date和timespan
`date$2014.11.22D17:43:40.123456789
`timespan$2014.11.22D17:43:40.123456789
/ 可以使用timestamp来作为key，作为join的条件
/ month是32bit有符号的整数值，格式为yyyy.mm，尾部标识符m，2000.01m为0
2015.11m
2001.01m=12
/ 尾部的m是不可缺少的，否则是float值
2001.01m=12
`int$2015.01m
/ month的值和对应的date中该月的第一天，是相等的
2015.07m=2015.07.01
/ minute类型存储32bit有符号整数值，格式为hh:mm，午夜开始计数
12:30
12:00=12*60
`int$12:00
/ minute与对应的time和timestamp为0的时刻相等
12:00=12:00:00.000
12:00=12:00:00.000000000
/ second类型保存32bit有符号的整数值，格式为hh:mm:ss，从午夜开始计数
23:59:59
23:59:59=-1+24*60*60
`int$12:34:56
`int$12:34:56.000
`long$12:34:56.000000000
12:34:56=12:34:56.000
12:34:56.000=12:34:56.000000000
/ 使用小数点调用时间组成成分
dt:2000.01.01T12:00:00.000
dt.year
dt.mm
dt.dd
ti:12:34:56.789
ti.hh
ti.mm
ti.ss
/ 这种写法不支持内部函数
/ 推荐使用强转格式，来抽取对应的值
`year$dt
`mm$dt
`month$dt
/ 抽取毫秒和纳秒值，从time类型中，强转成整数值，然后用求模mod求1000或1000000000
(`int$12:34:56.789) mod 1000
(`long$12:34:56.123456789) mod 1000000000
/ 算术无限值，空值
/ flaot的正无穷，负无穷，null值，0w，-0w，0n
/ long得正无穷，负无穷，null值，0W，-0W，0N
/ float是w，long是W，除法得到的值通常是float
/ 正值初以0，结果为正无穷，负值除以0，结果为负无穷，0w和-0w
/ 0除以0，没有意义，q中的值为0n
/ q的里面是，任何有效的算术表达式，生成结果而不是报运行时错误，除数为0，得到值而不是报错
42<0W
42<0W
/ 0N MIN_INT -9223372036854775808
/ -0W MIN_INT+1 -9223372036854775807
/ 0W MAX_INT +9223372036854775807
/ 0N < -0W < normal integer < 0W
9223372036854775806+1
-0W-1
-0W+1
/ q中没有溢出异常，最大值和最小值的回环
0W+1
0W+2
0W+3 
/ null值，q中没有空缺值
/ null值表，自己查
/ 二进制没有null值
/ 可以使用null，来测试值是否是null值
null 42
null `
null " "
null ""